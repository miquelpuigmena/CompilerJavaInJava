package lang.ast;
import beaver.*;
import java.util.ArrayList;

import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.util.Stack;
import java.util.zip.DeflaterOutputStream;

// This is a parser generated by NeoBeaver.
public class LangParser extends beaver.Parser {
  
	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}

  public static class Terminals {
    public static final short EOF = 0;
    public static final short ID = 1;
    public static final short SUB = 2;
    public static final short RIGHTPARENTHESIS = 3;
    public static final short COMMA = 4;
    public static final short INT = 5;
    public static final short SEMICOLON = 6;
    public static final short LEFTPARENTHESIS = 7;
    public static final short RIGHTBRACKET = 8;
    public static final short ADD = 9;
    public static final short WHILE = 10;
    public static final short IF = 11;
    public static final short RETURN = 12;
    public static final short NUMERAL = 13;
    public static final short LE = 14;
    public static final short LT = 15;
    public static final short EQ = 16;
    public static final short GE = 17;
    public static final short NE = 18;
    public static final short GT = 19;
    public static final short DIV = 20;
    public static final short MUL = 21;
    public static final short MOD = 22;
    public static final short LEFTBRACKET = 23;
    public static final short ELSEIF = 24;
    public static final short ELSE = 25;
    public static final short ASSIGN = 26;

    public static final String[] NAMES = {
        "EOF",
        "ID",
        "SUB",
        "RIGHTPARENTHESIS",
        "COMMA",
        "INT",
        "SEMICOLON",
        "LEFTPARENTHESIS",
        "RIGHTBRACKET",
        "ADD",
        "WHILE",
        "IF",
        "RETURN",
        "NUMERAL",
        "LE",
        "LT",
        "EQ",
        "GE",
        "NE",
        "GT",
        "DIV",
        "MUL",
        "MOD",
        "LEFTBRACKET",
        "ELSEIF",
        "ELSE",
        "ASSIGN",
    };
  }

  private final Action[] actions = {
    new Action() { // [0] stmt_list = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new List();
      }
    },
    new Action() { // [1] program =  stmt_list
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        return new Program(a);
      }
    },
    Action.RETURN, // [2] stmt =  func (default action: return symbol 1)
    new Action() { // [3] stmt_list =  stmt_list stmt
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final Stmt b = (Stmt) _symbols[offset + 2].value;
        return a.add(b);
      }
    },
    new Action() { // [4] GOAL =  program EOF
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Program program = (Program) _symbols[offset + 1].value;
        final Symbol sym2 = _symbols[offset + 2];
        return program;
      }
    },
    new Action() { // [5] id_decl =  ID
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol id = _symbols[offset + 1];
        return new IdDecl(id);
      }
    },
    new Action() { // [6] func_args_opt = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new List();
      }
    },
    new Action() { // [7] func_args =  func_arg
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdDecl a = (IdDecl) _symbols[offset + 1].value;
        return new List().add(a);
      }
    },
    Action.RETURN, // [8] func_args_opt =  func_args (default action: return symbol 1)
    RETURN2, // [9] func_arg =  INT id_decl (default action: return symbol 2)
    new Action() { // [10] block_stmts = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new List();
      }
    },
    new Action() { // [11] func_args =  func_args COMMA func_arg
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final Symbol COMMA = _symbols[offset + 2];
        final IdDecl b = (IdDecl) _symbols[offset + 3].value;
        return a.add(b);
      }
    },
    new Action() { // [12] block =  block_stmts
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        return new Block(a);
      }
    },
    Action.RETURN, // [13] block_stmt =  return_stmt (default action: return symbol 1)
    new Action() { // [14] block_stmts =  block_stmts block_stmt
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final Stmt b = (Stmt) _symbols[offset + 2].value;
        return a.add(b);
      }
    },
    new Action() { // [15] func =  INT id_decl LEFTPARENTHESIS func_args_opt RIGHTPARENTHESIS LEFTBRACKET block RIGHTBRACKET
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol INT = _symbols[offset + 1];
        final IdDecl a = (IdDecl) _symbols[offset + 2].value;
        final Symbol LEFTPARENTHESIS = _symbols[offset + 3];
        final List b = (List) _symbols[offset + 4].value;
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 5];
        final Symbol LEFTBRACKET = _symbols[offset + 6];
        final Block c = (Block) _symbols[offset + 7].value;
        final Symbol RIGHTBRACKET = _symbols[offset + 8];
        return new Func(a, new FuncArgs(b), c);
      }
    },
    new Action() { // [16] block_stmt =  func_call SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr f = (Expr) _symbols[offset + 1].value;
        final Symbol SEMICOLON = _symbols[offset + 2];
        return f;
      }
    },
    Action.RETURN, // [17] factor =  id_use (default action: return symbol 1)
    Action.RETURN, // [18] expr =  sum (default action: return symbol 1)
    new Action() { // [19] id_use =  ID
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol id = _symbols[offset + 1];
        return new IdUse(id);
      }
    },
    Action.RETURN, // [20] sum =  term (default action: return symbol 1)
    new Action() { // [21] integer =  NUMERAL
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol n = _symbols[offset + 1];
        return new Numeral(n);
      }
    },
    Action.RETURN, // [22] term =  factor (default action: return symbol 1)
    new Action() { // [23] assigmt =  INT id_decl SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol INT = _symbols[offset + 1];
        final IdDecl left = (IdDecl) _symbols[offset + 2].value;
        final Symbol SEMICOLON = _symbols[offset + 3];
        return new AssigmtStmt(left, new Opt());
      }
    },
    new Action() { // [24] factor =  SUB factor
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol SUB = _symbols[offset + 1];
        final Expr a = (Expr) _symbols[offset + 2].value;
        return new Mul(new Numeral("-1"), a);
      }
    },
    new Action() { // [25] return_stmt =  RETURN expr SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol RETURN = _symbols[offset + 1];
        final Expr e = (Expr) _symbols[offset + 2].value;
        final Symbol SEMICOLON = _symbols[offset + 3];
        return new ReturnStmt(e);
      }
    },
    new Action() { // [26] func_call =  id_decl LEFTPARENTHESIS RIGHTPARENTHESIS
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdDecl a = (IdDecl) _symbols[offset + 1].value;
        final Symbol LEFTPARENTHESIS = _symbols[offset + 2];
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 3];
        return new FuncCall(a, new FuncCallArgs(new List()));
      }
    },
    new Action() { // [27] func_call_args =  expr
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        return new List().add(a);
      }
    },
    new Action() { // [28] sum =  sum ADD term
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol ADD = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Add(a, b);
      }
    },
    new Action() { // [29] condition =  sum GE sum
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol GE = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new GE(a, b);
      }
    },
    new Action() { // [30] condition =  sum LE sum
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol LE = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new LE(a, b);
      }
    },
    new Action() { // [31] condition =  sum LT sum
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol LT = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new LT(a, b);
      }
    },
    new Action() { // [32] sum =  sum SUB term
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol SUB = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Sub(a, b);
      }
    },
    new Action() { // [33] condition =  sum EQ sum
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol EQ = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new EQ(a, b);
      }
    },
    new Action() { // [34] condition =  sum NE sum
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol NE = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new NE(a, b);
      }
    },
    new Action() { // [35] condition =  sum GT sum
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol GT = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new GT(a, b);
      }
    },
    new Action() { // [36] term =  term MOD factor
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol MOD = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Mod(a, b);
      }
    },
    new Action() { // [37] term =  term DIV factor
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol DIV = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Div(a, b);
      }
    },
    new Action() { // [38] term =  term MUL factor
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol MUL = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Mul(a, b);
      }
    },
    new Action() { // [39] factor =  LEFTPARENTHESIS expr RIGHTPARENTHESIS
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol LEFTPARENTHESIS = _symbols[offset + 1];
        final Expr a = (Expr) _symbols[offset + 2].value;
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 3];
        return a;
      }
    },
    new Action() { // [40] assigmt =  id_decl ASSIGN expr SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdDecl left = (IdDecl) _symbols[offset + 1].value;
        final Symbol ASSIGN = _symbols[offset + 2];
        final Expr right = (Expr) _symbols[offset + 3].value;
        final Symbol SEMICOLON = _symbols[offset + 4];
        return new AssigmtStmt(left, new Opt(right));
      }
    },
    new Action() { // [41] func_call =  id_decl LEFTPARENTHESIS func_call_args RIGHTPARENTHESIS
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdDecl a = (IdDecl) _symbols[offset + 1].value;
        final Symbol LEFTPARENTHESIS = _symbols[offset + 2];
        final List b = (List) _symbols[offset + 3].value;
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 4];
        return new FuncCall(a, new FuncCallArgs(b));
      }
    },
    new Action() { // [42] assigmt =  INT id_decl ASSIGN expr SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol INT = _symbols[offset + 1];
        final IdDecl left = (IdDecl) _symbols[offset + 2].value;
        final Symbol ASSIGN = _symbols[offset + 3];
        final Expr right = (Expr) _symbols[offset + 4].value;
        final Symbol SEMICOLON = _symbols[offset + 5];
        return new AssigmtStmt(left, new Opt(right));
      }
    },
    new Action() { // [43] func_call_args =  func_call_args COMMA expr
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final Symbol COMMA = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return a.add(b);
      }
    },
    new Action() { // [44] elseif_stmts = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new List();
      }
    },
    new Action() { // [45] while_stmt =  WHILE LEFTPARENTHESIS expr RIGHTPARENTHESIS LEFTBRACKET block RIGHTBRACKET
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol WHILE = _symbols[offset + 1];
        final Symbol LEFTPARENTHESIS = _symbols[offset + 2];
        final Expr a = (Expr) _symbols[offset + 3].value;
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 4];
        final Symbol LEFTBRACKET = _symbols[offset + 5];
        final Block b = (Block) _symbols[offset + 6].value;
        final Symbol RIGHTBRACKET = _symbols[offset + 7];
        return new WhileStmt(a, b);
      }
    },
    new Action() { // [46] else_stmt = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new Opt();
      }
    },
    new Action() { // [47] if_stmt =  IF LEFTPARENTHESIS expr RIGHTPARENTHESIS LEFTBRACKET block RIGHTBRACKET elseif_stmts else_stmt
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol IF = _symbols[offset + 1];
        final Symbol LEFTPARENTHESIS = _symbols[offset + 2];
        final Expr a = (Expr) _symbols[offset + 3].value;
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 4];
        final Symbol LEFTBRACKET = _symbols[offset + 5];
        final Block b = (Block) _symbols[offset + 6].value;
        final Symbol RIGHTBRACKET = _symbols[offset + 7];
        final List c = (List) _symbols[offset + 8].value;
        final Opt d = (Opt) _symbols[offset + 9].value;
        return new IfStmt(a, b, new ElseIfStmts(c), d);
      }
    },
    new Action() { // [48] elseif_stmts =  elseif_stmts elseif_stmt
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final Stmt b = (Stmt) _symbols[offset + 2].value;
        return a.add(b);
      }
    },
    new Action() { // [49] else_stmt =  ELSE LEFTBRACKET block RIGHTBRACKET
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol ELSE = _symbols[offset + 1];
        final Symbol LEFTBRACKET = _symbols[offset + 2];
        final Block b = (Block) _symbols[offset + 3].value;
        final Symbol RIGHTBRACKET = _symbols[offset + 4];
        return new Opt(new ElseStmt(b));
      }
    },
    new Action() { // [50] elseif_stmt =  ELSEIF LEFTPARENTHESIS expr RIGHTPARENTHESIS LEFTBRACKET block RIGHTBRACKET
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol ELSEIF = _symbols[offset + 1];
        final Symbol LEFTPARENTHESIS = _symbols[offset + 2];
        final Expr a = (Expr) _symbols[offset + 3].value;
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 4];
        final Symbol LEFTBRACKET = _symbols[offset + 5];
        final Block b = (Block) _symbols[offset + 6].value;
        final Symbol RIGHTBRACKET = _symbols[offset + 7];
        return new ElseIfStmt(a, b);
      }
    },
  };

      static final Action RETURN2 = new Action() {
        public Symbol reduce(Symbol[] _symbols, int offset) {
          return _symbols[offset + 2];
        }
      };
  static final ParsingTables PARSING_TABLES = new ParsingTables(
    "U9pjMsbiL5KK$cPfPzf2AOXiNIYq5DfIjh8fYg02uWeYhgZW1YeYIenHunBzeSR4VvgO#CE" +
    "eYJzCNAA$JDIV6iE#2691oWvIzar4hzzvxtLwxtHctdktPYo6U$BTSy#vzxldtFlkl9dEcm" +
    "8zuaeXYW8KgPLi5Q87UY66Iz0Nbs8m1c0eMuk81r2AdW0U9le3wczKe8h#9n17EKPZ64RWA" +
    "jIojzApnj1gH1r6eW5By2Z7FeL4Mj#rx3CzCmpFZP2IJ1ipinDhTifp6ptN2Kdz1Q#mPOw#" +
    "lXF$1dhSiUTJhFF6c9iCwsR3kaNzgTbpZBwvXdMhPysNdLBdr3clriVCywpRdTrC5HdhbEA" +
    "qtE$lj9gbxQlHs7#mAadt#fPaQ8R4EglEMj3Ah6ATGMyBrcbrsY9O7mkEpQwpg5EwbbgT4l" +
    "5XdLGdBOArN#L#pXmdM5LZ40Rwi8POHB8zKSTrBRKwBk93gx69XNeCJxMRDF#edAonDg7KC" +
    "LrBhOw9#B2iTYEVB3JxzBjbN9ezFX0hhQYZdLi1oiI0uoOOiOxeMcfrHCGdmyCYebtBzElI" +
    "THQcg3RLnb5jZZKfvRyCb#CAJCQLc9eXHQipRxckGoAEbdU$GwPV5uEbhofmKR#BY7Ojq#$" +
    "rJiVLc6RGhWaNnIjsUtXGHBHhcNvT35gmrrTwh0CYebtBzEjYqEpkX$QiMNcC5PgbzkjQQh" +
    "LV96Ua$E$XHLQNM6gVY6ZNClsw$5SPMgvhhwwbLdj5SaO2xl3fprpkj6BTPKDIUqH4kvRfr" +
    "yMWtOrxB6BjLhijKbnWmG7kjI6fNIAYNSlqUxsTt$Mcg9rg9qVjTAn925Qcg5RLIbPhIDOE" +
    "jOEi7M5OwZSHqQvb#htUJElQhhPprFQG6MvJsyZQ5fBLebh8QWd3Kh#AY7Ojqw#BmTeg8jg" +
    "rJByk1kiN4T6kPVfrCLXRH4IxbkdNnLZOVS7MdxORctKjjTeiuiFwMKIqQvb#NGoQtRrteU" +
    "yYCcMuITTIgqqYFYoxxm4sgeqM6Lh5meFX8x4yP4DI6tGjjTeWacsqDswzPwzlhzLw4PzOw" +
    "tGjjLedacNu8rZiwCU2hIIjF6v3KcjrBRLQA#B3MgDhgTKQaMoZlHwxpnjs9sgPJt$cygGL" +
    "QxaDIQtMjTHgjOWFosutdhRAS9MkfLQhHBADTdgQC0Bb68C2Z4GTMnDOrs8OMnM4j0JD6Ay" +
    "KHX732Q01ZOw$0AETaPMemc3sJEomK8qX68eQZCKuPomozENqA1P4GhBg7HQKLvXX0ButDZ" +
    "ihbsMkAn2F4MA8EyzU4jd7T1GCydJww1ohqTWnML6wrwyW4fRXnf9rXMVbCvOLgtzuZiskE" +
    "wo8paQIA4O9UlYmxDPb5oiPFfBrYRBBiD0k5gAfTaBpzyp9IkJgpHxBq#7MrVrPWNQZ$OuM" +
    "ZjLf5ksE7O8Ly6oOELhkHhJzJkzOHIb$ANgX3BtHntlktYy$h0mPsftvBcOeaGApj4Z1YsM" +
    "6#Rnls6LezqgnYsMtBcjM##U0VCIoONawv5qqltjuaTL5rWNnIh5XUJhafyhS$Vygo#xUQt" +
    "UzylctG$VVZImikrZvP5rSLpTbsVszdC$Fs7PtqNokw$$wFK2NlZq8bY46O61uLXTZsNqox" +
    "xOdgcCFk$td3RiJrMrtFiNAqoi5m8fNEXuDbCFzhUGSOYdnEl4XyGqXpyAE0f6UH1qndLX0" +
    "F4kyH7nA$4Ji0c$BH5#2SqNd4ei9pXLzd$YMs4AS06AbH0qnbLX8F4EyGtnESAxO7Y0U8PX" +
    "Nd7F5cLUSUSLV8puYE5Ty0y6v2deH3SGCWdCLl42yItn9h2Js0OLChB2Ic4pC8vOHRn0V4z" +
    "yJMubJG89v9Ue9hZ71kHBF4ymhyGNn8y6vafmhoRcId2l9kPASA$acmRcId2l9kPASgwYCw" +
    "4VC8XOHBnAl4byHgmdELHmd1X3Dn7nYEV4MyG71VIrk8Su09Ns89c8cmRqlMKAyHtnDCA#I" +
    "Wt8jUMat4bjVTY$pVj7fO6abshBqxIRsUUtZdZxPtiyGfPbuVY0laSLVaMRBCoFvFSKqkBz" +
    "7MkZvHtbFo9uZPAcyTdYRuBN19zwOsGJF6JwpoJ7aUhxJzkoGfmzhlWFUk4W6xWzKvpBuox" +
    "JsYf0F0Y$SqkmyPvx0TvoHH1Dl8ME8ShR7ExsY8wYZhzQnOpmZ4OmcQkaRuVpNK1HLj8SIW" +
    "uaXH2LHJJHoV1NxXrDN4FLEVmmr6jBjQWrLH2FYvCQf2yYFEMTn8XBE$m8qe8XsbEqunj4t" +
    "wHyTH15N");

  public LangParser() {
    super(PARSING_TABLES);
  }

  protected Symbol invokeReduceAction(int rule_num, int offset) {
    return actions[rule_num].reduce(_symbols, offset);
  }
}
