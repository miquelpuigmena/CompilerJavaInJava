package lang.ast;
import beaver.*;
import java.util.ArrayList;

import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.util.Stack;
import java.util.zip.DeflaterOutputStream;

// This is a parser generated by NeoBeaver.
public class LangParser extends beaver.Parser {
  
	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}

  public static class Terminals {
    public static final short EOF = 0;
    public static final short ID = 1;
    public static final short SUB = 2;
    public static final short DEF_FUNC = 3;
    public static final short RIGHTPARENTHESIS = 4;
    public static final short COMMA = 5;
    public static final short SEMICOLON = 6;
    public static final short INT = 7;
    public static final short LEFTPARENTHESIS = 8;
    public static final short RIGHTBRACKET = 9;
    public static final short ADD = 10;
    public static final short WHILE = 11;
    public static final short IF = 12;
    public static final short RETURN = 13;
    public static final short NUMERAL = 14;
    public static final short LE = 15;
    public static final short LT = 16;
    public static final short EQ = 17;
    public static final short GE = 18;
    public static final short NE = 19;
    public static final short GT = 20;
    public static final short DIV = 21;
    public static final short MUL = 22;
    public static final short MOD = 23;
    public static final short LEFTBRACKET = 24;
    public static final short ELSEIF = 25;
    public static final short ASSIGN = 26;
    public static final short ELSE = 27;

    public static final String[] NAMES = {
        "EOF",
        "ID",
        "SUB",
        "DEF_FUNC",
        "RIGHTPARENTHESIS",
        "COMMA",
        "SEMICOLON",
        "INT",
        "LEFTPARENTHESIS",
        "RIGHTBRACKET",
        "ADD",
        "WHILE",
        "IF",
        "RETURN",
        "NUMERAL",
        "LE",
        "LT",
        "EQ",
        "GE",
        "NE",
        "GT",
        "DIV",
        "MUL",
        "MOD",
        "LEFTBRACKET",
        "ELSEIF",
        "ASSIGN",
        "ELSE",
    };
  }

  private final Action[] actions = {
    new Action() { // [0] stmt_list = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new List();
      }
    },
    new Action() { // [1] program =  stmt_list
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        return new Program(a);
      }
    },
    new Action() { // [2] GOAL =  program EOF
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Program program = (Program) _symbols[offset + 1].value;
        final Symbol sym2 = _symbols[offset + 2];
        return program;
      }
    },
    new Action() { // [3] stmt_list =  stmt_list stmt
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final Stmt b = (Stmt) _symbols[offset + 2].value;
        return a.add(b);
      }
    },
    Action.RETURN, // [4] stmt =  func (default action: return symbol 1)
    new Action() { // [5] id_decl =  ID
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol id = _symbols[offset + 1];
        return new IdDecl(id);
      }
    },
    new Action() { // [6] func_args_opt = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new List();
      }
    },
    Action.RETURN, // [7] func_args_opt =  func_args (default action: return symbol 1)
    new Action() { // [8] func_args =  func_arg
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdDecl a = (IdDecl) _symbols[offset + 1].value;
        return new List().add(a);
      }
    },
    RETURN2, // [9] func_arg =  INT id_decl (default action: return symbol 2)
    new Action() { // [10] func_args =  func_args COMMA func_arg
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final Symbol COMMA = _symbols[offset + 2];
        final IdDecl b = (IdDecl) _symbols[offset + 3].value;
        return a.add(b);
      }
    },
    new Action() { // [11] block_stmts = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new List();
      }
    },
    new Action() { // [12] block =  block_stmts
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        return new Block(a);
      }
    },
    new Action() { // [13] func =  INT id_decl LEFTPARENTHESIS func_args_opt RIGHTPARENTHESIS LEFTBRACKET block RIGHTBRACKET
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol INT = _symbols[offset + 1];
        final IdDecl a = (IdDecl) _symbols[offset + 2].value;
        final Symbol LEFTPARENTHESIS = _symbols[offset + 3];
        final List b = (List) _symbols[offset + 4].value;
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 5];
        final Symbol LEFTBRACKET = _symbols[offset + 6];
        final Block c = (Block) _symbols[offset + 7].value;
        final Symbol RIGHTBRACKET = _symbols[offset + 8];
        return new Func(a, new FuncArgs(b), c);
      }
    },
    Action.RETURN, // [14] block_stmt =  assigmt (default action: return symbol 1)
    new Action() { // [15] block_stmts =  block_stmts block_stmt
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final Stmt b = (Stmt) _symbols[offset + 2].value;
        return a.add(b);
      }
    },
    new Action() { // [16] id_use =  ID
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol id = _symbols[offset + 1];
        return new IdUse(id);
      }
    },
    new Action() { // [17] block_stmt =  func_primary SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr f = (Expr) _symbols[offset + 1].value;
        final Symbol SEMICOLON = _symbols[offset + 2];
        return f;
      }
    },
    new Action() { // [18] block_stmt =  func_call SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr f = (Expr) _symbols[offset + 1].value;
        final Symbol SEMICOLON = _symbols[offset + 2];
        return f;
      }
    },
    Action.RETURN, // [19] factor =  func_primary (default action: return symbol 1)
    Action.RETURN, // [20] sum =  term (default action: return symbol 1)
    Action.RETURN, // [21] expr =  condition (default action: return symbol 1)
    new Action() { // [22] integer =  NUMERAL
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol n = _symbols[offset + 1];
        return new Numeral(n);
      }
    },
    Action.RETURN, // [23] term =  factor (default action: return symbol 1)
    new Action() { // [24] assigmt =  INT id_decl SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol INT = _symbols[offset + 1];
        final IdDecl left = (IdDecl) _symbols[offset + 2].value;
        final Symbol SEMICOLON = _symbols[offset + 3];
        return new AssigmtStmt(left, new Opt());
      }
    },
    new Action() { // [25] factor =  SUB factor
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol SUB = _symbols[offset + 1];
        final Expr a = (Expr) _symbols[offset + 2].value;
        return new Mul(new Numeral("-1"), a);
      }
    },
    new Action() { // [26] return_stmt =  RETURN expr SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol RETURN = _symbols[offset + 1];
        final Expr e = (Expr) _symbols[offset + 2].value;
        final Symbol SEMICOLON = _symbols[offset + 3];
        return new ReturnStmt(e);
      }
    },
    new Action() { // [27] func_call =  id_use LEFTPARENTHESIS RIGHTPARENTHESIS
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdUse a = (IdUse) _symbols[offset + 1].value;
        final Symbol LEFTPARENTHESIS = _symbols[offset + 2];
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 3];
        return new FuncCall(a, new FuncCallArgs(new List()));
      }
    },
    new Action() { // [28] func_call_args =  expr
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        return new List().add(a);
      }
    },
    new Action() { // [29] func_primary =  DEF_FUNC LEFTPARENTHESIS RIGHTPARENTHESIS
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol f = _symbols[offset + 1];
        final Symbol LEFTPARENTHESIS = _symbols[offset + 2];
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 3];
        return new FuncDefault(new DefFunc(f), new FuncCallArgs(new List()));
      }
    },
    new Action() { // [30] term =  term MOD factor
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol MOD = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Mod(a, b);
      }
    },
    new Action() { // [31] term =  term DIV factor
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol DIV = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Div(a, b);
      }
    },
    new Action() { // [32] term =  term MUL factor
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol MUL = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Mul(a, b);
      }
    },
    new Action() { // [33] factor =  LEFTPARENTHESIS expr RIGHTPARENTHESIS
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol LEFTPARENTHESIS = _symbols[offset + 1];
        final Expr a = (Expr) _symbols[offset + 2].value;
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 3];
        return a;
      }
    },
    new Action() { // [34] sum =  sum ADD term
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol ADD = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Add(a, b);
      }
    },
    new Action() { // [35] condition =  sum GE sum
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol GE = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new GE(a, b);
      }
    },
    new Action() { // [36] condition =  sum LE sum
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol LE = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new LE(a, b);
      }
    },
    new Action() { // [37] condition =  sum LT sum
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol LT = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new LT(a, b);
      }
    },
    new Action() { // [38] sum =  sum SUB term
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol SUB = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Sub(a, b);
      }
    },
    new Action() { // [39] condition =  sum EQ sum
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol EQ = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new EQ(a, b);
      }
    },
    new Action() { // [40] condition =  sum GT sum
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol GT = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new GT(a, b);
      }
    },
    new Action() { // [41] condition =  sum NE sum
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol NE = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new NE(a, b);
      }
    },
    new Action() { // [42] assigmt_use =  id_use ASSIGN expr SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdUse left = (IdUse) _symbols[offset + 1].value;
        final Symbol ASSIGN = _symbols[offset + 2];
        final Expr right = (Expr) _symbols[offset + 3].value;
        final Symbol SEMICOLON = _symbols[offset + 4];
        return new AssigmtUse(left, right);
      }
    },
    new Action() { // [43] func_call =  id_use LEFTPARENTHESIS func_call_args RIGHTPARENTHESIS
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdUse a = (IdUse) _symbols[offset + 1].value;
        final Symbol LEFTPARENTHESIS = _symbols[offset + 2];
        final List b = (List) _symbols[offset + 3].value;
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 4];
        return new FuncCall(a, new FuncCallArgs(b));
      }
    },
    new Action() { // [44] func_primary =  DEF_FUNC LEFTPARENTHESIS func_call_args RIGHTPARENTHESIS
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol f = _symbols[offset + 1];
        final Symbol LEFTPARENTHESIS = _symbols[offset + 2];
        final List b = (List) _symbols[offset + 3].value;
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 4];
        return new FuncDefault(new DefFunc(f), new FuncCallArgs(b));
      }
    },
    new Action() { // [45] assigmt =  INT id_decl ASSIGN expr SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol INT = _symbols[offset + 1];
        final IdDecl left = (IdDecl) _symbols[offset + 2].value;
        final Symbol ASSIGN = _symbols[offset + 3];
        final Expr right = (Expr) _symbols[offset + 4].value;
        final Symbol SEMICOLON = _symbols[offset + 5];
        return new AssigmtStmt(left, new Opt(right));
      }
    },
    new Action() { // [46] func_call_args =  func_call_args COMMA expr
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final Symbol COMMA = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return a.add(b);
      }
    },
    new Action() { // [47] elseif_stmts = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new List();
      }
    },
    new Action() { // [48] while_stmt =  WHILE LEFTPARENTHESIS expr RIGHTPARENTHESIS LEFTBRACKET block RIGHTBRACKET
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol WHILE = _symbols[offset + 1];
        final Symbol LEFTPARENTHESIS = _symbols[offset + 2];
        final Expr a = (Expr) _symbols[offset + 3].value;
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 4];
        final Symbol LEFTBRACKET = _symbols[offset + 5];
        final Block b = (Block) _symbols[offset + 6].value;
        final Symbol RIGHTBRACKET = _symbols[offset + 7];
        return new WhileStmt(a, b);
      }
    },
    new Action() { // [49] else_stmt = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new Opt();
      }
    },
    new Action() { // [50] elseif_stmts =  elseif_stmts elseif_stmt
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final Stmt b = (Stmt) _symbols[offset + 2].value;
        return a.add(b);
      }
    },
    new Action() { // [51] if_stmt =  IF LEFTPARENTHESIS expr RIGHTPARENTHESIS LEFTBRACKET block RIGHTBRACKET elseif_stmts else_stmt
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol IF = _symbols[offset + 1];
        final Symbol LEFTPARENTHESIS = _symbols[offset + 2];
        final Expr a = (Expr) _symbols[offset + 3].value;
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 4];
        final Symbol LEFTBRACKET = _symbols[offset + 5];
        final Block b = (Block) _symbols[offset + 6].value;
        final Symbol RIGHTBRACKET = _symbols[offset + 7];
        final List c = (List) _symbols[offset + 8].value;
        final Opt d = (Opt) _symbols[offset + 9].value;
        return new IfStmt(a, b, new ElseIfStmts(c), d);
      }
    },
    new Action() { // [52] else_stmt =  ELSE LEFTBRACKET block RIGHTBRACKET
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol ELSE = _symbols[offset + 1];
        final Symbol LEFTBRACKET = _symbols[offset + 2];
        final Block b = (Block) _symbols[offset + 3].value;
        final Symbol RIGHTBRACKET = _symbols[offset + 4];
        return new Opt(new ElseStmt(b));
      }
    },
    new Action() { // [53] elseif_stmt =  ELSEIF LEFTPARENTHESIS expr RIGHTPARENTHESIS LEFTBRACKET block RIGHTBRACKET
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol ELSEIF = _symbols[offset + 1];
        final Symbol LEFTPARENTHESIS = _symbols[offset + 2];
        final Expr a = (Expr) _symbols[offset + 3].value;
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 4];
        final Symbol LEFTBRACKET = _symbols[offset + 5];
        final Block b = (Block) _symbols[offset + 6].value;
        final Symbol RIGHTBRACKET = _symbols[offset + 7];
        return new ElseIfStmt(a, b);
      }
    },
  };

      static final Action RETURN2 = new Action() {
        public Symbol reduce(Symbol[] _symbols, int offset) {
          return _symbols[offset + 2];
        }
      };
  static final ParsingTables PARSING_TABLES = new ParsingTables(
    "U9pjcrcC55KKXlzPO7gcPrYLVHYMWO5XNuT5GKL14KK5HC4L5755H44X4UFov19ZJ3Gn6kE" +
    "B6XD3rCH4VTF4i2$AeeA8h8Biko3N$rHrTTqgUhgc3rW2Sa##gNDktR$FFRUgkgkN0Sec6e" +
    "Dyr4S14cY0XepAp48qmIMu5AKeGdEqHaTqHJMweoy6e1zweZzwe1SAqG8FSbGR0Atm4Br7C" +
    "HFjq05FqP#1zY7D46hOpAbq$#KCwuL6NSLHmPxhKxg$G$qtEFtFCDUDeJrZhSSOZ#ACEcat" +
    "X$QCitGJpCcqVokpdxJ6tXRGtHw89faJLdn78Eg9oO7eJjYj9B3lha1qTsYc3wHhWFbBJBQ" +
    "XCK$wO$onbd$SsIJ3Oo9RSSuADzynD5896olp7JL7LReZveWgOUuhwRQcEfavR0whT8TSRD" +
    "yS4eiGDjDaOsjBEgNySkOwo6qbMg8YOfu7Qe#ojiwvJI#TOR#BxPlzOX72gfZpTL7cs#TY#" +
    "sQVM8HGUxtl5SGytzyJDc#yqzgYM$fy0NfR3zadQpxbUiQjGqt4Vca3C$GDgeCkKnkiavaz" +
    "BhPlzeX52BN7RxUBxPlTOX7vBelOxxMXeNn$2c9#x7bX2mYrzMdp3OikBME#NOAO7tkURxW" +
    "2Ls9uGBTJJ95Gkov$269#x7bX2#ZizQof#tgQ7OAO7tjUs08J7HLQcn7fFTTW9Ax5rHYDwp" +
    "BK5$DvbjADKUgq#MxAMNTBrhrH#RnMz$Dikuljc#rYsTEPROAO7tjUs0AwhIwsRxQA$Jlrn" +
    "QwRc7NlsSztKNTkwEx9khVMPhO8OdxiUM4Bw3QRpQg4zsAAIZTLfOBvNH3pOyyBMq1udtAU" +
    "z#lcYMawcTaaYFcnvuKjeFjD4FDZpmjRGBTH4FDZpmjRGFUh8ER7dXUsW6w38ER7dkVRwVT" +
    "Bpdt1Uh5KF09rQwBxHKoX#raiDvtvIH3pOy$phPRwreafvhbMJA5R8vQRpgnsiNspMYn2zw" +
    "CWviUU5xQ0KFlyEJswbepp$44GysFF2rj0f$oynwnoiNspIYn2jzAipAsoCvid7jPaOtj49" +
    "pChN6pVh13BFjuiTt7wbdk8HUHRvcBxPfbOBOB7oEFaYHmBy$8jTR5zirGiOlmiPRubBhPl" +
    "beX52BNl0xJdsUo8$RMrEKhTqpgPMUnY#sQnM8HEkovpbVDSv6BxPf5OnFZUFEvzKOMkf0Z" +
    "TCOXU9tJcKQz16vJplAXARIlG3ktH0HrHILsrCwg7CUZbU0ETRqa6E7u$33vTOzYeI$SpAi" +
    "hmo94wlz$9rINhO#HbVZngi#kopJEe2qR1UORh2qJ6QaXaVTHQQg2k4FLGFuFU6fCUsyho2" +
    "vs$HU4nKGrvkIhyUUfqSUTJwd9UoPIkXLAddIUF7mfIFkUCOf94ASeYTCMQR6UG3u6epgih" +
    "ruAcgUUPY3bVtFLfh$Ty#xc9bAJtD4GZD4OJD7L#4z4CpPtULbu#v7lp3Auk6aJDKrjVhBe" +
    "wd2$sytGkEcs#Z3hrkiHy$EfuFOJNr3u$dJZY$FJdgQnFcqzxlMlpMPgSyiMzBZa#lvpDVB" +
    "Nhpc9zwkj8TDvTKwww6FDfx#lYVdvH7x#udpzZriL#$2xgpWdTV$1wfCeNz$lDkElJlc#C#" +
    "$ZzRtNPsxcZkq3gY$trNVdygRrkOxyFKUhEby#bOley2or9w$YEGpfVJE$xq$cqv$NvyZc3" +
    "zhv0Uvx5lfunNt#gymp0lEVyhx3aFwNaLzpZoGpo2lc8V4FaroF7WBpcf3SPGwQJ5ycxXEF" +
    "orf6ZG7wIz28Sap#5l43U9b#JLUGWKD2GL9DHP2gPJzuX2yWIiWCevECKLf4HP1APIzuYdv" +
    "55P2TGhv1q9CC8nzIRJTuWdvB5P3jGlu1K4DPMVoAPHLuZdv3loMPYWA8Mf8QC8wo$w6No8" +
    "VcMR2GdW4GJqfUmjWJhJx3#n0U4QvJuZXm0YZcck2SPJQQHvybxv2koXd1CIGF2#aj64jPV" +
    "yYnX$INl4wvHoLuWoVgJbOJr9pdl9EUTPFt9pyboiWKeBIAbP3YPJEQGrmddNVe5OVrbhB#" +
    "Cnwrig1nh7loLyzsJO6rgkq6sDcphoSOC$PiiVrjgUp0yBgJPbTeUpJQEKsiSYiipZAciHT" +
    "i3xdyIS3qn8TKt9JHcBDnVOynCnV8DDjSTBv4toQk4nm0VamNPvdgcyF6$jDRdkEMVilozg" +
    "Usn3Fg5f313$n3BdwVxvli2Q0F1QnIz#QesYAzhVKat#bMaE$kxSzk7T6L$7nGu$v7LYN4D" +
    "4ZoFyXZdeostFRWLv5ll3gGZgI3jIJLrxRXl0BVbf8lppNW1z$cq8nr8fKKu7imxl7BIXbJ" +
    "pVhGB##I$Q$gZ23sTIlBH2yNq2z6FVKF#0NmPZ4W=");

  public LangParser() {
    super(PARSING_TABLES);
  }

  protected Symbol invokeReduceAction(int rule_num, int offset) {
    return actions[rule_num].reduce(_symbols, offset);
  }
}
