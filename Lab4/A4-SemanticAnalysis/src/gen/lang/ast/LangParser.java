package lang.ast;
import beaver.*;
import java.util.ArrayList;

import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.util.Stack;
import java.util.zip.DeflaterOutputStream;

// This is a parser generated by NeoBeaver.
public class LangParser extends beaver.Parser {
  
	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}

  public static class Terminals {
    public static final short EOF = 0;
    public static final short ID = 1;
    public static final short SUB = 2;
    public static final short RIGHTPARENTHESIS = 3;
    public static final short COMMA = 4;
    public static final short INT = 5;
    public static final short SEMICOLON = 6;
    public static final short RIGHTBRACKET = 7;
    public static final short LEFTPARENTHESIS = 8;
    public static final short func_primary = 9;
    public static final short WHILE = 10;
    public static final short IF = 11;
    public static final short RETURN = 12;
    public static final short ADD = 13;
    public static final short NUMERAL = 14;
    public static final short LE = 15;
    public static final short LT = 16;
    public static final short EQ = 17;
    public static final short GE = 18;
    public static final short NE = 19;
    public static final short GT = 20;
    public static final short DIV = 21;
    public static final short MUL = 22;
    public static final short MOD = 23;
    public static final short LEFTBRACKET = 24;
    public static final short ELSEIF = 25;
    public static final short ASSIGN = 26;
    public static final short ELSE = 27;
    public static final short stmt = 28;

    public static final String[] NAMES = {
        "EOF",
        "ID",
        "SUB",
        "RIGHTPARENTHESIS",
        "COMMA",
        "INT",
        "SEMICOLON",
        "RIGHTBRACKET",
        "LEFTPARENTHESIS",
        "func_primary",
        "WHILE",
        "IF",
        "RETURN",
        "ADD",
        "NUMERAL",
        "LE",
        "LT",
        "EQ",
        "GE",
        "NE",
        "GT",
        "DIV",
        "MUL",
        "MOD",
        "LEFTBRACKET",
        "ELSEIF",
        "ASSIGN",
        "ELSE",
        "stmt",
    };
  }

  private final Action[] actions = {
    new Action() { // [0] func_list = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new List();
      }
    },
    new Action() { // [1] program =  func_list
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        return new Program(a);
      }
    },
    new Action() { // [2] func_list =  func_list func
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final Func b = (Func) _symbols[offset + 2].value;
        return a.add(b);
      }
    },
    new Action() { // [3] GOAL =  program EOF
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Program program = (Program) _symbols[offset + 1].value;
        final Symbol sym2 = _symbols[offset + 2];
        return program;
      }
    },
    new Action() { // [4] id_decl =  ID
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol id = _symbols[offset + 1];
        return new IdDecl(id);
      }
    },
    new Action() { // [5] func_args_opt = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new List();
      }
    },
    Action.RETURN, // [6] func_args_opt =  func_args (default action: return symbol 1)
    new Action() { // [7] func_args =  func_arg
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdDecl a = (IdDecl) _symbols[offset + 1].value;
        return new List().add(a);
      }
    },
    RETURN2, // [8] func_arg =  INT id_decl (default action: return symbol 2)
    new Action() { // [9] func_args =  func_args COMMA func_arg
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final Symbol COMMA = _symbols[offset + 2];
        final IdDecl b = (IdDecl) _symbols[offset + 3].value;
        return a.add(b);
      }
    },
    new Action() { // [10] block_stmts = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new List();
      }
    },
    new Action() { // [11] block =  block_stmts
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        return new Block(a);
      }
    },
    new Action() { // [12] func =  INT id_decl LEFTPARENTHESIS func_args_opt RIGHTPARENTHESIS LEFTBRACKET block RIGHTBRACKET
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol INT = _symbols[offset + 1];
        final IdDecl a = (IdDecl) _symbols[offset + 2].value;
        final Symbol LEFTPARENTHESIS = _symbols[offset + 3];
        final List b = (List) _symbols[offset + 4].value;
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 5];
        final Symbol LEFTBRACKET = _symbols[offset + 6];
        final Block c = (Block) _symbols[offset + 7].value;
        final Symbol RIGHTBRACKET = _symbols[offset + 8];
        return new Func(a, new FuncArgs(b), c);
      }
    },
    Action.RETURN, // [13] block_stmt =  assigmt (default action: return symbol 1)
    new Action() { // [14] block_stmts =  block_stmts block_stmt
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final Stmt b = (Stmt) _symbols[offset + 2].value;
        return a.add(b);
      }
    },
    new Action() { // [15] id_use =  ID
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol id = _symbols[offset + 1];
        return new IdUse(id);
      }
    },
    new Action() { // [16] block_stmt =  func_primary SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol f = _symbols[offset + 1];
        final Symbol SEMICOLON = _symbols[offset + 2];
        return f;
      }
    },
    new Action() { // [17] block_stmt =  func_call SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr f = (Expr) _symbols[offset + 1].value;
        final Symbol SEMICOLON = _symbols[offset + 2];
        return f;
      }
    },
    Action.RETURN, // [18] factor =  integer (default action: return symbol 1)
    Action.RETURN, // [19] sum =  term (default action: return symbol 1)
    Action.RETURN, // [20] expr =  condition (default action: return symbol 1)
    new Action() { // [21] integer =  NUMERAL
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol n = _symbols[offset + 1];
        return new Numeral(n);
      }
    },
    Action.RETURN, // [22] term =  factor (default action: return symbol 1)
    new Action() { // [23] func_call =  id_use LEFTPARENTHESIS RIGHTPARENTHESIS
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdUse a = (IdUse) _symbols[offset + 1].value;
        final Symbol LEFTPARENTHESIS = _symbols[offset + 2];
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 3];
        return new FuncCall(a, new FuncCallArgs(new List()));
      }
    },
    new Action() { // [24] func_call_args =  expr
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        return new List().add(a);
      }
    },
    new Action() { // [25] assigmt =  INT id_decl SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol INT = _symbols[offset + 1];
        final IdDecl left = (IdDecl) _symbols[offset + 2].value;
        final Symbol SEMICOLON = _symbols[offset + 3];
        return new AssigmtStmt(left, new Opt());
      }
    },
    new Action() { // [26] return_stmt =  RETURN expr SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol RETURN = _symbols[offset + 1];
        final Expr e = (Expr) _symbols[offset + 2].value;
        final Symbol SEMICOLON = _symbols[offset + 3];
        return new ReturnStmt(e);
      }
    },
    new Action() { // [27] factor =  SUB factor
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol SUB = _symbols[offset + 1];
        final Expr a = (Expr) _symbols[offset + 2].value;
        return new Mul(new Numeral("-1"), a);
      }
    },
    new Action() { // [28] assigmt_use =  id_use ASSIGN expr SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdUse left = (IdUse) _symbols[offset + 1].value;
        final Symbol ASSIGN = _symbols[offset + 2];
        final Expr right = (Expr) _symbols[offset + 3].value;
        final Symbol SEMICOLON = _symbols[offset + 4];
        return new AssigmtUse(left, right);
      }
    },
    new Action() { // [29] func_call =  id_use LEFTPARENTHESIS func_call_args RIGHTPARENTHESIS
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdUse a = (IdUse) _symbols[offset + 1].value;
        final Symbol LEFTPARENTHESIS = _symbols[offset + 2];
        final List b = (List) _symbols[offset + 3].value;
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 4];
        return new FuncCall(a, new FuncCallArgs(b));
      }
    },
    new Action() { // [30] term =  term MOD factor
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol MOD = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Mod(a, b);
      }
    },
    new Action() { // [31] term =  term DIV factor
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol DIV = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Div(a, b);
      }
    },
    new Action() { // [32] term =  term MUL factor
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol MUL = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Mul(a, b);
      }
    },
    new Action() { // [33] factor =  LEFTPARENTHESIS expr RIGHTPARENTHESIS
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol LEFTPARENTHESIS = _symbols[offset + 1];
        final Expr a = (Expr) _symbols[offset + 2].value;
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 3];
        return a;
      }
    },
    new Action() { // [34] sum =  sum ADD term
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol ADD = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Add(a, b);
      }
    },
    new Action() { // [35] condition =  sum GE sum
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol GE = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new GE(a, b);
      }
    },
    new Action() { // [36] condition =  sum LE sum
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol LE = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new LE(a, b);
      }
    },
    new Action() { // [37] condition =  sum LT sum
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol LT = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new LT(a, b);
      }
    },
    new Action() { // [38] sum =  sum SUB term
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol SUB = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Sub(a, b);
      }
    },
    new Action() { // [39] condition =  sum EQ sum
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol EQ = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new EQ(a, b);
      }
    },
    new Action() { // [40] condition =  sum GT sum
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol GT = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new GT(a, b);
      }
    },
    new Action() { // [41] condition =  sum NE sum
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol NE = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new NE(a, b);
      }
    },
    new Action() { // [42] func_call_args =  func_call_args COMMA expr
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final Symbol COMMA = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return a.add(b);
      }
    },
    new Action() { // [43] assigmt =  INT id_decl ASSIGN expr SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol INT = _symbols[offset + 1];
        final IdDecl left = (IdDecl) _symbols[offset + 2].value;
        final Symbol ASSIGN = _symbols[offset + 3];
        final Expr right = (Expr) _symbols[offset + 4].value;
        final Symbol SEMICOLON = _symbols[offset + 5];
        return new AssigmtStmt(left, new Opt(right));
      }
    },
    new Action() { // [44] elseif_stmts = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new List();
      }
    },
    new Action() { // [45] while_stmt =  WHILE LEFTPARENTHESIS expr RIGHTPARENTHESIS LEFTBRACKET block RIGHTBRACKET
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol WHILE = _symbols[offset + 1];
        final Symbol LEFTPARENTHESIS = _symbols[offset + 2];
        final Expr a = (Expr) _symbols[offset + 3].value;
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 4];
        final Symbol LEFTBRACKET = _symbols[offset + 5];
        final Block b = (Block) _symbols[offset + 6].value;
        final Symbol RIGHTBRACKET = _symbols[offset + 7];
        return new WhileStmt(a, b);
      }
    },
    new Action() { // [46] else_stmt = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new Opt();
      }
    },
    new Action() { // [47] elseif_stmts =  elseif_stmts elseif_stmt
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final Stmt b = (Stmt) _symbols[offset + 2].value;
        return a.add(b);
      }
    },
    new Action() { // [48] if_stmt =  IF LEFTPARENTHESIS expr RIGHTPARENTHESIS LEFTBRACKET block RIGHTBRACKET elseif_stmts else_stmt
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol IF = _symbols[offset + 1];
        final Symbol LEFTPARENTHESIS = _symbols[offset + 2];
        final Expr a = (Expr) _symbols[offset + 3].value;
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 4];
        final Symbol LEFTBRACKET = _symbols[offset + 5];
        final Block b = (Block) _symbols[offset + 6].value;
        final Symbol RIGHTBRACKET = _symbols[offset + 7];
        final List c = (List) _symbols[offset + 8].value;
        final Opt d = (Opt) _symbols[offset + 9].value;
        return new IfStmt(a, b, new ElseIfStmts(c), d);
      }
    },
    new Action() { // [49] else_stmt =  ELSE LEFTBRACKET block RIGHTBRACKET
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol ELSE = _symbols[offset + 1];
        final Symbol LEFTBRACKET = _symbols[offset + 2];
        final Block b = (Block) _symbols[offset + 3].value;
        final Symbol RIGHTBRACKET = _symbols[offset + 4];
        return new Opt(new ElseStmt(b));
      }
    },
    new Action() { // [50] elseif_stmt =  ELSEIF LEFTPARENTHESIS expr RIGHTPARENTHESIS LEFTBRACKET block RIGHTBRACKET
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol ELSEIF = _symbols[offset + 1];
        final Symbol LEFTPARENTHESIS = _symbols[offset + 2];
        final Expr a = (Expr) _symbols[offset + 3].value;
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 4];
        final Symbol LEFTBRACKET = _symbols[offset + 5];
        final Block b = (Block) _symbols[offset + 6].value;
        final Symbol RIGHTBRACKET = _symbols[offset + 7];
        return new ElseIfStmt(a, b);
      }
    },
  };

      static final Action RETURN2 = new Action() {
        public Symbol reduce(Symbol[] _symbols, int offset) {
          return _symbols[offset + 2];
        }
      };
  static final ParsingTables PARSING_TABLES = new ParsingTables(
    "U9pjcrji55KOn$#zTziYDxb3MmfjeOLIA2qNmHieAEA5co8AYgA8YeXeeecN#C2BJvgeYJx" +
    "uO4oC9chYYm$668s#A8e8fHGG510GKBnm4TJZ$yoPsJapdUrElz8kLSwNttvdllFzvrpcpE" +
    "vsTmlqobCAXSX67YvIIds9NkYB4en53lhZOjo3Ogoa7uQ1c8HQrA01up4Pur27DUeV308m7" +
    "AkHIpyKTp4JA2SZiPRrYe2cYHfpV2No0orJaotcU7ho#2QiTyuvpJrUW890vXKXvRpGyOt9" +
    "uuNgRxY5DIzdiPMznAhVRDLlKNybZvPQyLkj#ZAhVXkIHPrLP$MZWpskvQ5nFiXZ9ozP4X0" +
    "MTOOFHI9fWRZFFz5RAEqZxlEqEYrKdbAdX9tArbMNVbAXEgbE2fKdV6ym5aCwGDOZIwdhHx" +
    "2$F#W7OnI6e2ozKFtUjXQpLCR86HtPvs##DnYBSRwg#CCBbMgfi1EZ7IFkyrVV6up5aCgVJ" +
    "OvhqzxWHRqMsxmMjvIYtZhH1Ai#CKsVuhNDX1ADCNAYYtY57EKKYLBzudk3iQuShVhPzmPZ" +
    "CVgS4ID7bqlQz7bCc$R1gDTYMplAoeueCJFcQDiKTLIRzi6er#AsNuRBSMb8UKGTqO#2JZk" +
    "t#qHAzPCsxODHhyMsa59#FGzhqpuOzLfi2mrtJkJgpY9NuMhCnMnSYsiY9ofVs#lIjASiwf" +
    "0sxODHhyMsaFAWEYZiT3wk5ofl4Eewi$j#zBt1MFekrG7V6unrvMWpeboKfZrbKVkrQH#CU" +
    "YssdRFHNb2UZyhRqxIdB6gVxmt6OYX$qAPzCEgrs1QIokUv8lsuKfGxf4BrlJRjWr6lnRQG" +
    "SgysxODHhyMsa7AFDks3KQ$5jf3oEstQ1wDUYsqXvMvjsWUZNelR7l5#YA$PkzGkvkqAH6S" +
    "XVPcZTggTLEuKA5jLAvMj7LMg7Tgq3qQz5hSzUfujgeLvBOBHRbVRgTmkK3QhPYgREwoyCq" +
    "PEP57Rr3QXKlo9YzhgUuEnhkmJTyV8YIwhf4BrhUyDnjhBDwrgYnlPuc4iHf$V#DvWBANWN" +
    "dAVKxi$nfIY#zpiUuEnzlBTrWV4VNxjUuEn65Bv#rlvxdieHavqMITMFYmLggzyRp0MGobV" +
    "eKV4eztaUuEnzlATrchKOJmVyp09OsWrh4z19QhGn1sY$GZk5KqPoZ4I5HY5qHX7vLYbKCl" +
    "TehzFcg0pwHj8ewEQsaRZ7IDbI$ZOd7DoyZWhjh9DdyejdAUVOsUdggDZ#IfPa8DSFkOxtx" +
    "Qb6ITpXbhAGYKioD4p52cpv7tgUSgKcUXJh1IjgwCSB5RAH#jUJ#VkB2095A4O9J6K1R8UE" +
    "zMdTNzsiCyOzufzRrbH#MZpEpB2W59#PsTYjF8#vSycsVRpPZBQY$H67$H5F#TN2WCm48ES" +
    "bkIrvQj3jdKUQwMTtpd46ArydjsgxCGUag#GlYuofUi5AvI1wndpNcdxZ6BlMokQSjz6A#F" +
    "i#8wFDcByyj56w6BssQdT9rIUawjoVYaZvobVeOpj8L6VcNYlsSDULp9mbycLygiYttqzQu" +
    "KkABjk3ydliapiFlbVaPbuZl$VAzELyqlv7vjdp$h49HDA#QSytVRv48QGOHBbEUcpspwhi" +
    "VgKxzkUzNUs$3LRllioihPYPJVVPG0sFED$FJI2J2TBT9myJzucdv83G5OkAICpo5Bo665E" +
    "rgja4paAPEUGAZARC2VxIV8YUOzi9Sp9kOZKaZba5NcMl4O#95l8II2tFwadyyaQmfpSryd" +
    "7P0Sv0#GD98ra0LbBdYDlai$8Fd8Mo1zEffB5P3tXUFFV8L#GGq117gaWCyaoyZXvYRnFDf" +
    "DZG64HgIQSK#4AyXHvXNn0FYBCIN1E2SufCPTmJWcEDy4v9JYd1CURu9oAEASYpgc8SofQH" +
    "3QIDyWdP0zXJZ5pYfl8GhAECAVuBSBrAzuFb6IHKZADSDuboyaBv5toEJcihoSly5RI$BIv" +
    "sAtQsx3i8RiZudkj#a7NdmZdHUZskVvKk8t3wKjAtNfLU#U1#RNra8Zuh1Jvywnw7U7QOQ4" +
    "LqxyOMqbM4#uHF4gU87gPDeREzNAwUSPOXoFkkM35Mbn$F6Byt2F8ZuZNMFKDak#6UsXfSA" +
    "xY5Bu#rV6Tu2HIpNeDOpNqzMGCO$LynwR$CwUIn#DHY5hwAiPBwMlfDVgRumeoYfIHaSuto" +
    "JcOJA$$xx6Hb3DlAd8PpsLxJf9oKa56MuIF9vEno7DsN0CAd6$7ctY#2Npk7SVpJMHish#s" +
    "fphq");

  public LangParser() {
    super(PARSING_TABLES);
  }

  protected Symbol invokeReduceAction(int rule_num, int offset) {
    return actions[rule_num].reduce(_symbols, offset);
  }
}
