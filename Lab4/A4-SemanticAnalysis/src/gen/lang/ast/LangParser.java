package lang.ast;
import beaver.*;
import java.util.ArrayList;

import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.util.Stack;
import java.util.zip.DeflaterOutputStream;

// This is a parser generated by NeoBeaver.
public class LangParser extends beaver.Parser {
  
	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}

  public static class Terminals {
    public static final short EOF = 0;
    public static final short ID = 1;
    public static final short SUB = 2;
    public static final short RIGHTPARENTHESIS = 3;
    public static final short COMMA = 4;
    public static final short INT = 5;
    public static final short SEMICOLON = 6;
    public static final short RIGHTBRACKET = 7;
    public static final short LEFTPARENTHESIS = 8;
    public static final short func_primary = 9;
    public static final short WHILE = 10;
    public static final short IF = 11;
    public static final short RETURN = 12;
    public static final short ADD = 13;
    public static final short NUMERAL = 14;
    public static final short LE = 15;
    public static final short LT = 16;
    public static final short EQ = 17;
    public static final short GE = 18;
    public static final short NE = 19;
    public static final short GT = 20;
    public static final short DIV = 21;
    public static final short MUL = 22;
    public static final short MOD = 23;
    public static final short LEFTBRACKET = 24;
    public static final short ELSEIF = 25;
    public static final short ASSIGN = 26;
    public static final short ELSE = 27;
    public static final short stmt = 28;

    public static final String[] NAMES = {
        "EOF",
        "ID",
        "SUB",
        "RIGHTPARENTHESIS",
        "COMMA",
        "INT",
        "SEMICOLON",
        "RIGHTBRACKET",
        "LEFTPARENTHESIS",
        "func_primary",
        "WHILE",
        "IF",
        "RETURN",
        "ADD",
        "NUMERAL",
        "LE",
        "LT",
        "EQ",
        "GE",
        "NE",
        "GT",
        "DIV",
        "MUL",
        "MOD",
        "LEFTBRACKET",
        "ELSEIF",
        "ASSIGN",
        "ELSE",
        "stmt",
    };
  }

  private final Action[] actions = {
    new Action() { // [0] func_list = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new List();
      }
    },
    new Action() { // [1] program =  func_list
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        return new Program(a);
      }
    },
    new Action() { // [2] func_list =  func_list func
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final Func b = (Func) _symbols[offset + 2].value;
        return a.add(b);
      }
    },
    new Action() { // [3] GOAL =  program EOF
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Program program = (Program) _symbols[offset + 1].value;
        final Symbol sym2 = _symbols[offset + 2];
        return program;
      }
    },
    new Action() { // [4] id_decl =  ID
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol id = _symbols[offset + 1];
        return new IdDecl(id);
      }
    },
    new Action() { // [5] func_args_opt = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new List();
      }
    },
    Action.RETURN, // [6] func_args_opt =  func_args (default action: return symbol 1)
    new Action() { // [7] func_args =  func_arg
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdDecl a = (IdDecl) _symbols[offset + 1].value;
        return new List().add(a);
      }
    },
    RETURN2, // [8] func_arg =  INT id_decl (default action: return symbol 2)
    new Action() { // [9] func_args =  func_args COMMA func_arg
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final Symbol COMMA = _symbols[offset + 2];
        final IdDecl b = (IdDecl) _symbols[offset + 3].value;
        return a.add(b);
      }
    },
    new Action() { // [10] block_stmts = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new List();
      }
    },
    new Action() { // [11] block =  block_stmts
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        return new Block(a);
      }
    },
    new Action() { // [12] func =  INT id_decl LEFTPARENTHESIS func_args_opt RIGHTPARENTHESIS LEFTBRACKET block RIGHTBRACKET
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol INT = _symbols[offset + 1];
        final IdDecl a = (IdDecl) _symbols[offset + 2].value;
        final Symbol LEFTPARENTHESIS = _symbols[offset + 3];
        final List b = (List) _symbols[offset + 4].value;
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 5];
        final Symbol LEFTBRACKET = _symbols[offset + 6];
        final Block c = (Block) _symbols[offset + 7].value;
        final Symbol RIGHTBRACKET = _symbols[offset + 8];
        return new Func(a, new FuncArgs(b), c);
      }
    },
    Action.RETURN, // [13] block_stmt =  assigmt (default action: return symbol 1)
    new Action() { // [14] block_stmts =  block_stmts block_stmt
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final Stmt b = (Stmt) _symbols[offset + 2].value;
        return a.add(b);
      }
    },
    new Action() { // [15] id_use =  ID
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol id = _symbols[offset + 1];
        return new IdUse(id);
      }
    },
    new Action() { // [16] block_stmt =  func_primary SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol f = _symbols[offset + 1];
        final Symbol SEMICOLON = _symbols[offset + 2];
        return f;
      }
    },
    new Action() { // [17] block_stmt =  func_call SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr f = (Expr) _symbols[offset + 1].value;
        final Symbol SEMICOLON = _symbols[offset + 2];
        return f;
      }
    },
    Action.RETURN, // [18] factor =  integer (default action: return symbol 1)
    Action.RETURN, // [19] sum =  term (default action: return symbol 1)
    Action.RETURN, // [20] expr =  condition (default action: return symbol 1)
    new Action() { // [21] integer =  NUMERAL
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol n = _symbols[offset + 1];
        return new Numeral(n);
      }
    },
    Action.RETURN, // [22] term =  factor (default action: return symbol 1)
    new Action() { // [23] func_call =  id_use LEFTPARENTHESIS RIGHTPARENTHESIS
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdUse a = (IdUse) _symbols[offset + 1].value;
        final Symbol LEFTPARENTHESIS = _symbols[offset + 2];
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 3];
        return new FuncCall(a, new FuncCallArgs(new List()));
      }
    },
    new Action() { // [24] func_call_args =  expr
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        return new List().add(a);
      }
    },
    new Action() { // [25] assigmt =  INT id_decl SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol INT = _symbols[offset + 1];
        final IdDecl left = (IdDecl) _symbols[offset + 2].value;
        final Symbol SEMICOLON = _symbols[offset + 3];
        return new AssigmtStmt(left, new Opt());
      }
    },
    new Action() { // [26] factor =  SUB factor
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol SUB = _symbols[offset + 1];
        final Expr a = (Expr) _symbols[offset + 2].value;
        return new Mul(new Numeral("-1"), a);
      }
    },
    new Action() { // [27] return_stmt =  RETURN expr SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol RETURN = _symbols[offset + 1];
        final Expr e = (Expr) _symbols[offset + 2].value;
        final Symbol SEMICOLON = _symbols[offset + 3];
        return new ReturnStmt(e);
      }
    },
    new Action() { // [28] assigmt_use =  id_use ASSIGN expr SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdUse left = (IdUse) _symbols[offset + 1].value;
        final Symbol ASSIGN = _symbols[offset + 2];
        final Expr right = (Expr) _symbols[offset + 3].value;
        final Symbol SEMICOLON = _symbols[offset + 4];
        return new AssigmtUse(left, right);
      }
    },
    new Action() { // [29] func_call =  id_use LEFTPARENTHESIS func_call_args RIGHTPARENTHESIS
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdUse a = (IdUse) _symbols[offset + 1].value;
        final Symbol LEFTPARENTHESIS = _symbols[offset + 2];
        final List b = (List) _symbols[offset + 3].value;
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 4];
        return new FuncCall(a, new FuncCallArgs(b));
      }
    },
    new Action() { // [30] term =  term MOD factor
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol MOD = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Mod(a, b);
      }
    },
    new Action() { // [31] term =  term DIV factor
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol DIV = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Div(a, b);
      }
    },
    new Action() { // [32] term =  term MUL factor
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol MUL = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Mul(a, b);
      }
    },
    new Action() { // [33] sum =  sum ADD term
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol ADD = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Add(a, b);
      }
    },
    new Action() { // [34] condition =  sum GE sum
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol GE = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new GE(a, b);
      }
    },
    new Action() { // [35] condition =  sum LE sum
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol LE = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new LE(a, b);
      }
    },
    new Action() { // [36] condition =  sum LT sum
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol LT = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new LT(a, b);
      }
    },
    new Action() { // [37] condition =  sum EQ sum
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol EQ = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new EQ(a, b);
      }
    },
    new Action() { // [38] sum =  sum SUB term
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol SUB = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Sub(a, b);
      }
    },
    new Action() { // [39] condition =  sum NE sum
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol NE = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new NE(a, b);
      }
    },
    new Action() { // [40] condition =  sum GT sum
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol GT = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new GT(a, b);
      }
    },
    new Action() { // [41] factor =  LEFTPARENTHESIS expr RIGHTPARENTHESIS
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol LEFTPARENTHESIS = _symbols[offset + 1];
        final Expr a = (Expr) _symbols[offset + 2].value;
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 3];
        return a;
      }
    },
    new Action() { // [42] func_call_args =  func_call_args COMMA expr
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final Symbol COMMA = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return a.add(b);
      }
    },
    new Action() { // [43] assigmt =  INT id_decl ASSIGN expr SEMICOLON
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol INT = _symbols[offset + 1];
        final IdDecl left = (IdDecl) _symbols[offset + 2].value;
        final Symbol ASSIGN = _symbols[offset + 3];
        final Expr right = (Expr) _symbols[offset + 4].value;
        final Symbol SEMICOLON = _symbols[offset + 5];
        return new AssigmtStmt(left, new Opt(right));
      }
    },
    new Action() { // [44] elseif_stmts = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new List();
      }
    },
    new Action() { // [45] while_stmt =  WHILE LEFTPARENTHESIS condition RIGHTPARENTHESIS LEFTBRACKET block RIGHTBRACKET
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol WHILE = _symbols[offset + 1];
        final Symbol LEFTPARENTHESIS = _symbols[offset + 2];
        final CompExpr a = (CompExpr) _symbols[offset + 3].value;
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 4];
        final Symbol LEFTBRACKET = _symbols[offset + 5];
        final Block b = (Block) _symbols[offset + 6].value;
        final Symbol RIGHTBRACKET = _symbols[offset + 7];
        return new WhileStmt(a, b);
      }
    },
    new Action() { // [46] else_stmt = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new Opt();
      }
    },
    new Action() { // [47] elseif_stmts =  elseif_stmts elseif_stmt
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final Stmt b = (Stmt) _symbols[offset + 2].value;
        return a.add(b);
      }
    },
    new Action() { // [48] if_stmt =  IF LEFTPARENTHESIS condition RIGHTPARENTHESIS LEFTBRACKET block RIGHTBRACKET elseif_stmts else_stmt
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol IF = _symbols[offset + 1];
        final Symbol LEFTPARENTHESIS = _symbols[offset + 2];
        final CompExpr a = (CompExpr) _symbols[offset + 3].value;
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 4];
        final Symbol LEFTBRACKET = _symbols[offset + 5];
        final Block b = (Block) _symbols[offset + 6].value;
        final Symbol RIGHTBRACKET = _symbols[offset + 7];
        final List c = (List) _symbols[offset + 8].value;
        final Opt d = (Opt) _symbols[offset + 9].value;
        return new IfStmt(a, b, new ElseIfStmts(c), d);
      }
    },
    new Action() { // [49] else_stmt =  ELSE LEFTBRACKET block RIGHTBRACKET
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol ELSE = _symbols[offset + 1];
        final Symbol LEFTBRACKET = _symbols[offset + 2];
        final Block b = (Block) _symbols[offset + 3].value;
        final Symbol RIGHTBRACKET = _symbols[offset + 4];
        return new Opt(new ElseStmt(b));
      }
    },
    new Action() { // [50] elseif_stmt =  ELSEIF LEFTPARENTHESIS condition RIGHTPARENTHESIS LEFTBRACKET block RIGHTBRACKET
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol ELSEIF = _symbols[offset + 1];
        final Symbol LEFTPARENTHESIS = _symbols[offset + 2];
        final CompExpr a = (CompExpr) _symbols[offset + 3].value;
        final Symbol RIGHTPARENTHESIS = _symbols[offset + 4];
        final Symbol LEFTBRACKET = _symbols[offset + 5];
        final Block b = (Block) _symbols[offset + 6].value;
        final Symbol RIGHTBRACKET = _symbols[offset + 7];
        return new ElseIfStmt(a, b);
      }
    },
  };

      static final Action RETURN2 = new Action() {
        public Symbol reduce(Symbol[] _symbols, int offset) {
          return _symbols[offset + 2];
        }
      };
  static final ParsingTables PARSING_TABLES = new ParsingTables(
    "U9pjcrbm54KOn$$9vjeDuPGRSa4II3W2uGP53WLH545G50z4L52v54jBgpnUVB2iqXUjqWS" +
    "VzCqgjSe7Ntomj2mV14Na3X4K4HHGFBW4RVyzFRFJCqooiryWMw7IN$tsw$sw$$Drz$JCRd" +
    "OtG5crKYX1FWhHNIcr1MNeXMuOYGJwu2eyX5AieX#CVXYF1jHZ0aPX34QZ2O#e$p00m12iG" +
    "G7z83p0da0bgS9wrgj3cadkymKe2hLCjPvFnxHGwmsOuaOMepZGywPGprlTvqjSVrkwVQdw" +
    "5uyxumDhlcgPLR$Tgj#Hhj#fBbZnvLRzBgk#8ZIIUvrCvzLv$UXWZtiT8ehkbox9g1vnYlg" +
    "73ocHj5YSynnw2AKznJdFghD2vHbrHfXKjgwwz9OArMbrMgWyvNk3iHZIlhACBEMk7yfyVz" +
    "Ftnp0CH4LceVhhubhCKXEZp$38Q6sMcT95$UbxWx4OqheSv1mXplc7xmt6OaZbTvEJshGtU" +
    "56lnJQlnItbQBGEDDQgZykGKxoskL1YOem#qKMyGevoiaIfVlUzmTZb7AtwpVS6Op5oNXsZ" +
    "ZoupBifvGflsmQZNObiRofgibCUrQH#CUYrk#qnSYsj2ocFgc7wCELkxN1#fdKNcO2wkmsp" +
    "Cm$n8PVjsdqYfVjMcVJ3gjTWMKehF9sxCC9lMH$kBDks3KQ$5jf1KlhOBnQCzgatxODHhiI" +
    "qalHct27CUKKU4mrqar777HqOlwuvNF$lUO2p6Q7DmbNKfkvHkkJj3Uwj57TQcVJ3gjTWMK" +
    "lxaUuEn64dl4O$saEyDnc8eVzIcVJ3gjTWMaihFodsPnzLAMIaLgX#qQH#CUYssXPG7jMaV" +
    "Z7ejjeMK1xHf7unwBRQ5bDzhqpuOzLhSzeXtKdm$rA9QsAyb49tL#ifOolrgFvNx1SfcrKn" +
    "biq2vJ#sZSb#sIhLNc$R1gDVYjaUlq1wrX$ts24QxM#scSdVMezsbJVjWr6knBIIzFyQued" +
    "FkL3k5Il5dDMg7xmt6BcTEh8xH9xeyA1MgxtnlCDPMVzEgjhkHxHx6OkJyrlS6OwqA7YPhd" +
    "TgZCQOKdNERxmt6skhljZucplcDxmt6OaZbxs$bksz3Z3xHPQDOkKagL5$xtc0iXbA#Ga#8" +
    "HxlLzmPZRVLtMkkSRptgK8Zn646hPtqoQb2BITmXsW$bNj5Ke19LgCOm3CSeAaSgXGRkbaB" +
    "wiRedVHEPwAYcNAJndgFL5lCyt3eX7SdBqDDx7lPLW1aVHrSOK6Mk8yl#paYSJ0aKyB78#P" +
    "ukqAuY2WPPzPAe7d4A4dg68cMUFAUUfqoPYvnYfMXT7UK0iL8#MlTyEbTdCKaYXL9qYw4ib" +
    "cLiLqwaQrckSfnhnRwsh6XHTfaifNoUyYjRdZCNyvJVJVBj#sOwMaPwe2TweRVp#uQ#w8V#" +
    "JalwtFBL8TywZhNIpYyaOenMFiyELRPZ3ybNI9yNcTBrWXNAmVcCUQrSV4UnzwqLRNNVHYl" +
    "ZxFXBaZD25tFciN96Ajkr#uJAIt9MibJAxxVodF8LoiLeS$7kJVvUCpyoUfbtlEixzAxPfU" +
    "nIjbFPZgjCVkzpVVRNYdoqyfovkCVB$$xCnQl35QBCLAuKPUTQeOoZxLoVrUH2AVzygCC#M" +
    "S90CbYYl2GvE#nJ7YkdVDzshh$GvQ$PyjsNaxKLApluAWEm#Nd$YwMXP1fPvdwRzHfvZtnE" +
    "3WDv1QI2p23BoPE4VVBU8bl9SI0$GMh9NC8##K#HDyc7P0TXdqHtqa3caTNaHV8s#OHi9wU" +
    "1WZwaaImaQmdx5Bn3FYKjv1nGs9zC98l9El8oUPTyGGwHyq3H43A5B2MRoAlaVV8LEGeK5v" +
    "9gCfEi84#Jryb7P1iv0PIaI0sPGrQIPmddNF8nsKcQWIJx93cdv7p2EIKvtYJdbEISadi9v" +
    "vJYd5ASKufpId5EgOs4SqfzHWwG2q0f#vIoJ#aIie6yGjYdz4l2DUwMHyh9TCBpr6qzUOPy" +
    "GBOGphkiI9zJdkGTPDTpveJlqzw6vG1fYOWVjEf7N7ygt2z2TyZrPy9j74ulKkxMQziw3jj" +
    "7au4HyUbjQ6QxVX9P0FrRLu3xmlbbt2goHkzrmlK2rmilj76ibpBDDSPQ77EF1Iksn$Kd8t" +
    "A#GOeYueki#cRHrykTjJHX31ydyvLg3DyJZYTrhDSpLa$VI4OmriZtRle$YchuV3HAq41Vo" +
    "tWvVGEzHd$xN4s6amfIvNmRdS04UlrVbvNiCv5#2WeOBs1x8aqr6HR2ZbKwnqdmE8NEtcj2" +
    "iVCD#oGUSoplmgDul76CJVqV3jrlkm==");

  public LangParser() {
    super(PARSING_TABLES);
  }

  protected Symbol invokeReduceAction(int rule_num, int offset) {
    return actions[rule_num].reduce(_symbols, offset);
  }
}
